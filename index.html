<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hermit Crab Shell Search Simulator</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { Play, Pause, RotateCcw, Shuffle } = lucide;

        const HermitCrabSimulation = () => {
          const canvasRef = useRef(null);
          const [isRunning, setIsRunning] = useState(false);
          const [crabSize, setCrabSize] = useState(10);
          const [numShells, setNumShells] = useState(15);
          const [dispersion, setDispersion] = useState(50);
          const [memory, setMemory] = useState(5);
          const [elapsedTime, setElapsedTime] = useState(0);
          const [isComplete, setIsComplete] = useState(false);
          const [shellChanges, setShellChanges] = useState(0);
          const [changeHistory, setChangeHistory] = useState([]);
          const [totalRuns, setTotalRuns] = useState(0);
          const [crabName, setCrabName] = useState('');
          const [pathLength, setPathLength] = useState(0);
          const simRef = useRef(null);
          const startTimeRef = useRef(null);
          const animationFrameRef = useRef(null);

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            function generateShellSize(type, crabSize) {
              if (type === 'optimal') return crabSize * (0.97 + Math.random() * 0.06);
              else if (type === 'too-large') return crabSize * (1.2 + Math.random() * 0.8);
              else return crabSize * (0.2 + Math.random() * 0.6);
            }

            function generateShells(count, dispersionValue, crabSize) {
              const shells = [];
              const minDistance = 5;
              const tooLargeCount = Math.floor((count - 1) / 2);
              const tooSmallCount = count - 1 - tooLargeCount;
              let shellTypes = ['optimal'];
              for (let i = 0; i < tooLargeCount; i++) shellTypes.push('too-large');
              for (let i = 0; i < tooSmallCount; i++) shellTypes.push('too-small');
              for (let i = shellTypes.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shellTypes[i], shellTypes[j]] = [shellTypes[j], shellTypes[i]];
              }
              
              if (dispersionValue < 33) {
                const centerX = width / 2, centerY = height / 2, clusterRadius = 100;
                for (let i = 0; i < count; i++) {
                  let placed = false, attempts = 0;
                  while (!placed && attempts < 100) {
                    const angle = Math.random() * Math.PI * 2, dist = Math.random() * clusterRadius;
                    const x = centerX + Math.cos(angle) * dist, y = centerY + Math.sin(angle) * dist;
                    const size = generateShellSize(shellTypes[i], crabSize);
                    const shellScreenSize = (size * 0.625 + 1.25) * 3.78;
                    if (x >= shellScreenSize && x <= width - shellScreenSize && y >= shellScreenSize && y <= height - shellScreenSize) {
                      let overlaps = false;
                      for (let shell of shells) {
                        const dx = shell.x - x, dy = shell.y - y, dist = Math.sqrt(dx * dx + dy * dy);
                        const otherScreenSize = (shell.size * 0.625 + 1.25) * 3.78;
                        if (dist < (shellScreenSize + otherScreenSize) * 0.6 + minDistance) { overlaps = true; break; }
                      }
                      if (!overlaps) { shells.push({ x, y, size, id: i, timesInvestigated: 0 }); placed = true; }
                    }
                    attempts++;
                  }
                }
              } else if (dispersionValue > 66) {
                for (let i = 0; i < count; i++) {
                  let placed = false, attempts = 0;
                  while (!placed && attempts < 100) {
                    const size = generateShellSize(shellTypes[i], crabSize);
                    const shellScreenSize = (size * 0.625 + 1.25) * 3.78;
                    const x = shellScreenSize + Math.random() * (width - 2 * shellScreenSize);
                    const y = shellScreenSize + Math.random() * (height - 2 * shellScreenSize);
                    let overlaps = false;
                    for (let shell of shells) {
                      const dx = shell.x - x, dy = shell.y - y, dist = Math.sqrt(dx * dx + dy * dy);
                      const otherScreenSize = (shell.size * 0.625 + 1.25) * 3.78;
                      if (dist < (shellScreenSize + otherScreenSize) * 0.6 + minDistance) { overlaps = true; break; }
                    }
                    if (!overlaps) { shells.push({ x, y, size, id: i, timesInvestigated: 0 }); placed = true; }
                    attempts++;
                  }
                }
              } else {
                const numClusters = Math.floor(2 + Math.random() * 3);
                const shellsPerCluster = Math.ceil(count / numClusters);
                let shellIndex = 0;
                for (let c = 0; c < numClusters && shellIndex < count; c++) {
                  const centerX = 100 + Math.random() * (width - 200);
                  const centerY = 100 + Math.random() * (height - 200);
                  const clusterRadius = 30 + Math.random() * 70;
                  for (let i = 0; i < shellsPerCluster && shellIndex < count; i++) {
                    let placed = false, attempts = 0;
                    while (!placed && attempts < 100) {
                      const angle = Math.random() * Math.PI * 2, dist = Math.random() * clusterRadius;
                      const x = centerX + Math.cos(angle) * dist, y = centerY + Math.sin(angle) * dist;
                      const size = generateShellSize(shellTypes[shellIndex], crabSize);
                      const shellScreenSize = (size * 0.625 + 1.25) * 3.78;
                      if (x >= shellScreenSize && x <= width - shellScreenSize && y >= shellScreenSize && y <= height - shellScreenSize) {
                        let overlaps = false;
                        for (let shell of shells) {
                          const dx = shell.x - x, dy = shell.y - y, dist = Math.sqrt(dx * dx + dy * dy);
                          const otherScreenSize = (shell.size * 0.625 + 1.25) * 3.78;
                          if (dist < (shellScreenSize + otherScreenSize) * 0.6 + minDistance) { overlaps = true; break; }
                        }
                        if (!overlaps) { shells.push({ x, y, size, id: shellIndex, timesInvestigated: 0 }); placed = true; shellIndex++; }
                      }
                      attempts++;
                    }
                  }
                }
              }
              return shells;
            }

            function init() {
              const shells = generateShells(numShells, dispersion, crabSize);
              const screenSize = (crabSize * 0.625 + 1.25) * 3.78;
              let startX, startY, validPosition = false, attempts = 0;
              const minDistance = screenSize * 5;
              while (!validPosition && attempts < 100) {
                startX = screenSize * 3 + Math.random() * (width - screenSize * 6);
                startY = screenSize * 3 + Math.random() * (height - screenSize * 6);
                validPosition = true;
                for (let shell of shells) {
                  const dx = shell.x - startX, dy = shell.y - startY, dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < minDistance) { validPosition = false; break; }
                }
                attempts++;
              }
              if (!validPosition) { startX = width / 2; startY = height / 2; }
              return {
                shells,
                crab: {
                  x: startX, y: startY, optimalSize: crabSize, screenSize, currentShellSize: crabSize * 0.8,
                  angle: Math.random() * Math.PI * 2, speed: 2.5 - (crabSize / 20) * 1.5, wanderAngle: 0,
                  state: 'exploring', currentTarget: null, lastInvestigated: null, assessmentTime: 0,
                  assessmentDuration: 0, detectionRange: 800, investigatedShells: {}, shellChanges: 0,
                  lastChangeType: null, pathLength: 0, lastX: startX, lastY: startY
                }
              };
            }

            if (!simRef.current) simRef.current = init();

            function getShellColor(shell, crabSize) {
              const fitDiff = Math.abs(shell.size - crabSize) / crabSize;
              if (fitDiff <= 0.05) return '#22c55e';
              else if (shell.size < crabSize) {
                const intensity = Math.min(Math.abs(fitDiff) * 2, 1);
                return `rgb(239, ${Math.floor(68 + (1 - intensity) * 150)}, ${Math.floor(68 + (1 - intensity) * 150)})`;
              } else {
                const intensity = Math.min(Math.abs(fitDiff) * 2, 1);
                return `rgb(${Math.floor(56 + (1 - intensity) * 150)}, ${Math.floor(189 + (1 - intensity) * 50)}, ${Math.floor(248 + (1 - intensity) * 7)})`;
              }
            }

            function getCurrentShellColor(currentShellSize, optimalSize) {
              const fitDiff = Math.abs(currentShellSize - optimalSize) / optimalSize;
              if (fitDiff <= 0.05) return '#22c55e';
              else if (currentShellSize < optimalSize) {
                const intensity = Math.min(Math.abs(fitDiff) * 2, 1);
                return `rgb(239, ${Math.floor(68 + (1 - intensity) * 150)}, ${Math.floor(68 + (1 - intensity) * 150)})`;
              } else {
                const intensity = Math.min(Math.abs(fitDiff) * 2, 1);
                return `rgb(${Math.floor(56 + (1 - intensity) * 150)}, ${Math.floor(189 + (1 - intensity) * 50)}, ${Math.floor(248 + (1 - intensity) * 7)})`;
              }
            }

            function drawShell(ctx, shell, crabSize) {
              const shellScreenSize = (shell.size * 0.625 + 1.25) * 3.78;
              const chemicalStrength = shellScreenSize * 1.8;
              const gradient = ctx.createRadialGradient(shell.x, shell.y, 0, shell.x, shell.y, chemicalStrength);
              gradient.addColorStop(0, 'rgba(147, 51, 234, 0.15)');
              gradient.addColorStop(1, 'rgba(147, 51, 234, 0)');
              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.arc(shell.x, shell.y, chemicalStrength, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = getShellColor(shell, crabSize);
              ctx.beginPath();
              ctx.arc(shell.x, shell.y, shellScreenSize * 0.6, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
              ctx.beginPath();
              ctx.arc(shell.x + shellScreenSize * 0.2, shell.y, shellScreenSize * 0.3, 0, Math.PI * 2);
              ctx.fill();
            }

            function detectChemicals(crab, shells, memoryLevel) {
              let strongestShell = null, maxStrength = 0;
              for (let shell of shells) {
                const timesVisited = crab.investigatedShells[shell.id] || 0;
                if (timesVisited > 0 && Math.random() > 1 - ((memoryLevel - 1) / 9)) continue;
                const dx = shell.x - crab.x, dy = shell.y - crab.y, dist = Math.sqrt(dx * dx + dy * dy);
                const perceivedStrength = shell.size / (1 + (dist * dist) / 10000);
                if (perceivedStrength > maxStrength && dist > 5) {
                  maxStrength = perceivedStrength;
                  strongestShell = { shell, strength: perceivedStrength, distance: dist };
                }
              }
              return strongestShell;
            }

            function calculateAssessmentTime(shellSize, optimalSize) {
              const fitDiff = Math.abs(shellSize - optimalSize) / optimalSize;
              if (fitDiff <= 0.1) return 600;
              else if (fitDiff >= 0.5) return 300;
              else return Math.floor((10 - (5 * ((fitDiff - 0.1) / 0.4))) * 60);
            }

            function shouldSwitch(currentSize, newSize, optimalSize) {
              return Math.abs(newSize - optimalSize) < Math.abs(currentSize - optimalSize);
            }

            function updateCrab(crab, shells) {
              if (crab.state === 'exploring') {
                const detected = detectChemicals(crab, shells, memory);
                let chemotaxisBias = 0, targetAngle = crab.angle;
                if (detected && detected.shell !== crab.lastInvestigated) {
                  const dx = detected.shell.x - crab.x, dy = detected.shell.y - crab.y, dist = detected.distance;
                  if (dist < 20) {
                    crab.currentTarget = detected.shell;
                    crab.state = 'assessing';
                    crab.assessmentTime = 0;
                    crab.investigatedShells[detected.shell.id] = (crab.investigatedShells[detected.shell.id] || 0) + 1;
                    let baseTime = calculateAssessmentTime(detected.shell.size, crab.optimalSize);
                    if (detected.shell.timesInvestigated > 0) baseTime = Math.floor(baseTime * 0.5);
                    crab.assessmentDuration = baseTime;
                    detected.shell.timesInvestigated++;
                    return 'running';
                  } else {
                    chemotaxisBias = Math.min(detected.strength / 50, 1);
                    targetAngle = Math.atan2(dy, dx);
                  }
                }
                if (chemotaxisBias > 0.01) {
                  const angleDiff = targetAngle - crab.angle;
                  const normalizedDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
                  crab.angle += normalizedDiff * (0.05 + chemotaxisBias * 0.25);
                  const randomness = 1 - chemotaxisBias;
                  crab.wanderAngle += (Math.random() - 0.5) * 0.5 * randomness;
                  crab.wanderAngle = Math.max(-0.5, Math.min(0.5, crab.wanderAngle)) * randomness;
                  crab.angle += crab.wanderAngle * 0.1;
                } else {
                  crab.wanderAngle += (Math.random() - 0.5) * 0.6;
                  crab.wanderAngle = Math.max(-1, Math.min(1, crab.wanderAngle));
                  crab.angle += crab.wanderAngle * 0.2;
                }
                const newX = crab.x + Math.cos(crab.angle) * crab.speed;
                const newY = crab.y + Math.sin(crab.angle) * crab.speed;
                const dx = newX - crab.lastX, dy = newY - crab.lastY;
                crab.pathLength += Math.sqrt(dx * dx + dy * dy);
                crab.lastX = crab.x; crab.lastY = crab.y;
                const margin = crab.screenSize;
                if (newX < margin || newX > width - margin) { crab.angle = Math.PI - crab.angle; crab.wanderAngle = 0; }
                if (newY < margin || newY > height - margin) { crab.angle = -crab.angle; crab.wanderAngle = 0; }
                crab.x = Math.max(margin, Math.min(width - margin, newX));
                crab.y = Math.max(margin, Math.min(height - margin, newY));
              } else if (crab.state === 'assessing') {
                crab.assessmentTime++;
                if (crab.assessmentTime >= crab.assessmentDuration) {
                  const oldSize = crab.currentShellSize;
                  if (shouldSwitch(crab.currentShellSize, crab.currentTarget.size, crab.optimalSize)) {
                    crab.currentShellSize = crab.currentTarget.size;
                    crab.shellChanges++;
                    const fitDiff = Math.abs(crab.currentShellSize - crab.optimalSize) / crab.optimalSize;
                    let changeType = fitDiff <= 0.05 ? 'optimal' : crab.currentShellSize > oldSize ? 'larger' : 'smaller';
                    crab.lastChangeType = changeType;
                    setChangeHistory(prev => [...prev, changeType]);
                    setShellChanges(crab.shellChanges);
                  }
                  if (Math.abs(crab.currentShellSize - crab.optimalSize) / crab.optimalSize <= 0.05) {
                    setPathLength(crab.pathLength);
                    return 'complete';
                  }
                  crab.lastInvestigated = crab.currentTarget;
                  const dx = crab.x - crab.currentTarget.x, dy = crab.y - crab.currentTarget.y;
                  crab.angle = Math.sqrt(dx * dx + dy * dy) < 1 ? Math.random() * Math.PI * 2 : Math.atan2(dy, dx) + (Math.random() - 0.5) * Math.PI / 3;
                  crab.state = 'exploring';
                  crab.currentTarget = null;
                  crab.wanderAngle = 0;
                  for (let i = 0; i < 10; i++) {
                    crab.x += Math.cos(crab.angle) * crab.speed;
                    crab.y += Math.sin(crab.angle) * crab.speed;
                  }
                  const margin = crab.screenSize;
                  crab.x = Math.max(margin, Math.min(width - margin, crab.x));
                  crab.y = Math.max(margin, Math.min(height - margin, crab.y));
                }
              }
              return 'running';
            }

            function drawCrab(ctx, crab) {
              const currentShellScreenSize = (crab.currentShellSize * 0.625 + 1.25) * 3.78;
              ctx.fillStyle = getCurrentShellColor(crab.currentShellSize, crab.optimalSize);
              ctx.beginPath();
              ctx.arc(crab.x, crab.y, currentShellScreenSize * 0.5, 0, Math.PI * 2);
              ctx.fill();
              if (crab.lastChangeType) {
                ctx.strokeStyle = crab.lastChangeType === 'optimal' ? '#22c55e' : crab.lastChangeType === 'larger' ? '#38bdf8' : '#ef4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(crab.x - currentShellScreenSize * 0.4, crab.y);
                ctx.lineTo(crab.x + currentShellScreenSize * 0.4, crab.y);
                ctx.stroke();
              }
              ctx.fillStyle = '#f97316';
              ctx.beginPath();
              ctx.arc(crab.x, crab.y, crab.screenSize * 0.6, 0, Math.PI * 2);
              ctx.fill();
              const clawAngle1 = crab.angle - Math.PI / 4, clawAngle2 = crab.angle + Math.PI / 4;
              ctx.strokeStyle = '#ea580c';
              ctx.lineWidth = Math.max(2, crab.screenSize * 0.15);
              ctx.beginPath();
              ctx.moveTo(crab.x, crab.y);
              ctx.lineTo(crab.x + Math.cos(clawAngle1) * crab.screenSize, crab.y + Math.sin(clawAngle1) * crab.screenSize);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(crab.x, crab.y);
              ctx.lineTo(crab.x + Math.cos(clawAngle2) * crab.screenSize, crab.y + Math.sin(clawAngle2) * crab.screenSize);
              ctx.stroke();
              ctx.fillStyle = '#000';
              const eyeOffset = crab.screenSize * 0.4, eyeSize = Math.max(2, crab.screenSize * 0.1);
              ctx.beginPath();
              ctx.arc(crab.x + Math.cos(crab.angle - 0.3) * eyeOffset, crab.y + Math.sin(crab.angle - 0.3) * eyeOffset, eyeSize, 0, Math.PI * 2);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(crab.x + Math.cos(crab.angle + 0.3) * eyeOffset, crab.y + Math.sin(crab.angle + 0.3) * eyeOffset, eyeSize, 0, Math.PI * 2);
              ctx.fill();
              if (crab.state === 'assessing') {
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(crab.x, crab.y, crab.screenSize * 1.3, 0, Math.PI * 2);
                ctx.stroke();
                const progress = crab.assessmentTime / crab.assessmentDuration;
                ctx.strokeStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(crab.x, crab.y, crab.screenSize * 1.3, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                ctx.stroke();
              }
            }

            function animate() {
              if (!isRunning) return;
              ctx.fillStyle = '#0f172a';
              ctx.fillRect(0, 0, width, height);
              const { shells, crab } = simRef.current;
              if (startTimeRef.current) setElapsedTime((Date.now() - startTimeRef.current) / 1000);
              const status = updateCrab(crab, shells);
              if (status === 'complete') { setIsRunning(false); setIsComplete(true); }
              shells.forEach(shell => drawShell(ctx, shell, crabSize));
              drawCrab(ctx, crab);
              ctx.fillStyle = '#fff';
              ctx.font = 'bold 20px monospace';
              ctx.fillText(`Time: ${elapsedTime.toFixed(2)}s`, 10, 25);
              ctx.font = '12px monospace';
              ctx.fillText(`State: ${crab.state}`, 10, 45);
              ctx.fillText(`Shell fit: ${((crab.currentShellSize - crab.optimalSize) / crab.optimalSize * 100).toFixed(1)}%`, 10, 60);
              ctx.fillText(`Shell changes: ${crab.shellChanges}`, 10, 75);
              ctx.fillStyle = '#22c55e';
              ctx.fillRect(width - 140, 8, 15, 15);
              ctx.fillStyle = '#fff';
              ctx.fillText('Optimal', width - 120, 20);
              ctx.fillStyle = '#38bdf8';
              ctx.fillRect(width - 140, 28, 15, 15);
              ctx.fillStyle = '#fff';
              ctx.fillText('Too large', width - 120, 40);
              ctx.fillStyle = '#ef4444';
              ctx.fillRect(width - 140, 48, 15, 15);
              ctx.fillStyle = '#fff';
              ctx.fillText('Too small', width - 120, 60);
              ctx.fillText('Shell changes:', width - 140, 85);
              let tallyX = width - 140, tallyY = 100;
              changeHistory.forEach((changeType, index) => {
                ctx.strokeStyle = changeType === 'optimal' ? '#22c55e' : changeType === 'larger' ? '#38bdf8' : '#ef4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(tallyX + (index % 10) * 8, tallyY);
                ctx.lineTo(tallyX + (index % 10) * 8, tallyY + 10);
                ctx.stroke();
                if ((index + 1) % 10 === 0) tallyY += 15;
              });
              if (isComplete) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = '#22c55e';
                ctx.font = 'bold 40px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('OPTIMAL SHELL FOUND!', width / 2, height / 2);
                ctx.font = 'bold 28px monospace';
                ctx.fillText(`Time: ${elapsedTime.toFixed(2)}s`, width / 2, height / 2 + 45);
              }
              animationFrameRef.current = requestAnimationFrame(animate);
            }

            if (isRunning) {
              if (!startTimeRef.current) startTimeRef.current = Date.now();
              animate();
            }

            return () => { if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current); };
          }, [isRunning, crabSize, numShells, dispersion, memory, elapsedTime, isComplete, changeHistory]);

          const handleStart = () => {
            if (!simRef.current) handleReset();
            startTimeRef.current = Date.now();
            setElapsedTime(0);
            setIsComplete(false);
            setIsRunning(true);
            setTotalRuns(prev => prev + 1);
          };

          const handleReset = () => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            simRef.current = null;
            startTimeRef.current = null;
            setElapsedTime(0);
            setIsComplete(false);
            setShellChanges(0);
            setChangeHistory([]);
            setPathLength(0);
            setIsRunning(false);
          };

          const handleRandomize = () => {
            setCrabSize(Math.floor(Math.random() * 20) + 1);
            setNumShells(Math.floor(Math.random() * 26) + 5);
            setDispersion(Math.floor(Math.random() * 101));
            setMemory(Math.floor(Math.random() * 10) + 1);
            setTimeout(handleReset, 100);
          };

          const handleSaveData = () => {
            if (!crabName.trim()) { alert('Please enter a crab name before saving!'); return; }
            const now = new Date();
            const csvContent = `Crab Name,Date,Time,Duration (s),Shell Changes,Path Length,Crab Size,Number of Shells,Dispersion,Memory\n${crabName},${now.toLocaleDateString('en-US')},${now.toLocaleTimeString('en-US')},${elapsedTime.toFixed(2)},${shellChanges},${pathLength.toFixed(2)},${crabSize},${numShells},${dispersion},${memory}`;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `hermit_crab_${crabName.replace(/\s+/g, '_')}_${Date.now()}.csv`;
            link.click();
          };

          return (
            <div className="w-full min-h-screen bg-slate-900 flex items-center justify-center p-4">
              <div className="bg-slate-800 rounded-lg shadow-2xl p-6 max-w-5xl w-full">
                <h1 className="text-2xl font-bold text-white mb-4">Hermit Crab Shell Search Simulator</h1>
                <canvas ref={canvasRef} width={900} height={600} className="w-full border-2 border-slate-700 rounded mb-4" />
                <div className="space-y-4">
                  <div className="flex gap-2 flex-wrap">
                    <button onClick={handleStart} disabled={isRunning} className="flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 text-white rounded transition-colors"><Play size={16} /> Start</button>
                    <button onClick={() => setIsRunning(false)} disabled={!isRunning} className="flex items-center gap-2 px-4 py-2 bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white rounded transition-colors"><Pause size={16} /> Pause</button>
                    <button onClick={handleReset} className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors"><RotateCcw size={16} /> Reset</button>
                    <button onClick={handleRandomize} className="flex items-center gap-2 px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded transition-colors"><Shuffle size={16} /> Randomize</button>
                  </div>
                  <div className="bg-slate-700 p-3 rounded">
                    <label className="text-white text-sm mb-2 block">Name Your Crab:</label>
                    <div className="flex gap-2">
                      <input type="text" value={crabName} onChange={(e) => setCrabName(e.target.value)} placeholder="Enter crab name" className="flex-1 px-3 py-2 bg-slate-600 text-white rounded border border-slate-500" />
                      <button onClick={handleSaveData} disabled={!isComplete} className="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 text-white rounded transition-colors">Save Data</button>
                    </div>
                  </div>
                  <div className="text-white text-sm bg-slate-700 p-2 rounded"><p>Total Simulations Run: {totalRuns}</p></div>
                  <div className="space-y-3">
                    <div><label className="text-white text-sm mb-1 block">Crab Size: {crabSize} ({(crabSize * 0.625 + 1.25).toFixed(1)}mm)</label><input type="range" min="1" max="20" step="1" value={crabSize} onChange={(e) => { setCrabSize(parseFloat(e.target.value)); handleReset(); }} className="w-full" /></div>
                    <div><label className="text-white text-sm mb-1 block">Number of Shells: {numShells}</label><input type="range" min="5" max="30" step="1" value={numShells} onChange={(e) => { setNumShells(parseInt(e.target.value)); handleReset(); }} className="w-full" /></div>
                    <div><label className="text-white text-sm mb-1 block">Dispersion: {dispersion < 33 ? 'Clumped' : dispersion < 67 ? 'Moderate' : 'Dispersed'}</label><input type="range" min="0" max="100" step="1" value={dispersion} onChange={(e) => { setDispersion(parseInt(e.target.value)); handleReset(); }} className="w-full" /></div>
                    <div><label className="text-white text-sm mb-1 block">Memory: {memory} {memory === 1 ? '(revisits)' : memory === 10 ? '(never revisits)' : ''}</label><input type="range" min="1" max="10" step="1" value={memory} onChange={(e) => setMemory(parseInt(e.target.value))} className="w-full" /></div>
                  </div>
                </div>
                <div className="mt-4 text-sm text-slate-300 space-y-1">
                  <p>• Crab starts 80% of optimal size, 5 body lengths from nearest shell</p>
                  <p>• Shell distribution: ~50% too large (blue), ~50% too small (red), 1 optimal (green)</p>
                  <p>• Investigation time: 10s for good fits (90-110%), 5s for bad fits (≥50%)</p>
                  <p>• Memory: controls revisitation (1=always, 10=never)</p>
                  <p>• Chemotaxis: larger shells emit stronger chemical signals</p>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<HermitCrabSimulation />);
    </script>
</body>
</html>
