import React, { useEffect, useRef, useState } from 'react';
import { Play, Pause, RotateCcw, Shuffle } from 'lucide-react';

const HermitCrabSimulation = () => {
  const canvasRef = useRef(null);
  const [isRunning, setIsRunning] = useState(false);
  const [crabSize, setCrabSize] = useState(10);
  const [numShells, setNumShells] = useState(15);
  const [dispersion, setDispersion] = useState(50);
  const [memory, setMemory] = useState(5);
  const [elapsedTime, setElapsedTime] = useState(0);
  const [isComplete, setIsComplete] = useState(false);
  const [shellChanges, setShellChanges] = useState(0);
  const [changeHistory, setChangeHistory] = useState([]);
  const [totalRuns, setTotalRuns] = useState(0);
  const [crabName, setCrabName] = useState('');
  const [pathLength, setPathLength] = useState(0);
  
  const simRef = useRef(null);
  const startTimeRef = useRef(null);
  const animationFrameRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    function generateShellSize(type, crabSize) {
      if (type === 'optimal') {
        // Ensure optimal is truly within 5%: between 97% and 103%
        return crabSize * (0.97 + Math.random() * 0.06);
      } else if (type === 'too-large') {
        return crabSize * (1.2 + Math.random() * 0.8);
      } else {
        return crabSize * (0.2 + Math.random() * 0.6);
      }
    }

    function generateShells(count, dispersionValue, crabSize) {
      const shells = [];
      const minDistance = 5;
      
      const tooLargeCount = Math.floor((count - 1) / 2);
      const tooSmallCount = count - 1 - tooLargeCount;
      
      let shellTypes = [];
      shellTypes.push('optimal');
      for (let i = 0; i < tooLargeCount; i++) {
        shellTypes.push('too-large');
      }
      for (let i = 0; i < tooSmallCount; i++) {
        shellTypes.push('too-small');
      }
      
      for (let i = shellTypes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shellTypes[i], shellTypes[j]] = [shellTypes[j], shellTypes[i]];
      }
      
      if (dispersionValue < 33) {
        const centerX = width / 2;
        const centerY = height / 2;
        const clusterRadius = 100;
        
        for (let i = 0; i < count; i++) {
          let placed = false;
          let attempts = 0;
          
          while (!placed && attempts < 100) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * clusterRadius;
            const x = centerX + Math.cos(angle) * dist;
            const y = centerY + Math.sin(angle) * dist;
            
            const type = shellTypes[i];
            let size = generateShellSize(type, crabSize);
            const shellScreenSize = (size * 0.625 + 1.25) * 3.78;
            
            if (x >= shellScreenSize && x <= width - shellScreenSize && 
                y >= shellScreenSize && y <= height - shellScreenSize) {
              
              let overlaps = false;
              for (let shell of shells) {
                const dx = shell.x - x;
                const dy = shell.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const otherScreenSize = (shell.size * 0.625 + 1.25) * 3.78;
                const minDist = (shellScreenSize + otherScreenSize) * 0.6 + minDistance;
                
                if (dist < minDist) {
                  overlaps = true;
                  break;
                }
              }
              
              if (!overlaps) {
                shells.push({ x, y, size, id: i, timesInvestigated: 0 });
                placed = true;
              }
            }
            attempts++;
          }
        }
      } else if (dispersionValue > 66) {
        for (let i = 0; i < count; i++) {
          let placed = false;
          let attempts = 0;
          
          while (!placed && attempts < 100) {
            const type = shellTypes[i];
            let size = generateShellSize(type, crabSize);
            const shellScreenSize = (size * 0.625 + 1.25) * 3.78;
            
            const x = shellScreenSize + Math.random() * (width - 2 * shellScreenSize);
            const y = shellScreenSize + Math.random() * (height - 2 * shellScreenSize);
            
            let overlaps = false;
            for (let shell of shells) {
              const dx = shell.x - x;
              const dy = shell.y - y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const otherScreenSize = (shell.size * 0.625 + 1.25) * 3.78;
              const minDist = (shellScreenSize + otherScreenSize) * 0.6 + minDistance;
              
              if (dist < minDist) {
                overlaps = true;
                break;
              }
            }
            
            if (!overlaps) {
              shells.push({ x, y, size, id: i, timesInvestigated: 0 });
              placed = true;
            }
            attempts++;
          }
        }
      } else {
        const numClusters = Math.floor(2 + Math.random() * 3);
        const shellsPerCluster = Math.ceil(count / numClusters);
        let shellIndex = 0;
        
        for (let c = 0; c < numClusters && shellIndex < count; c++) {
          const centerX = 100 + Math.random() * (width - 200);
          const centerY = 100 + Math.random() * (height - 200);
          const clusterRadius = 30 + Math.random() * 70;
          
          for (let i = 0; i < shellsPerCluster && shellIndex < count; i++) {
            let placed = false;
            let attempts = 0;
            
            while (!placed && attempts < 100) {
              const angle = Math.random() * Math.PI * 2;
              const dist = Math.random() * clusterRadius;
              const x = centerX + Math.cos(angle) * dist;
              const y = centerY + Math.sin(angle) * dist;
              
              const type = shellTypes[shellIndex];
              let size = generateShellSize(type, crabSize);
              const shellScreenSize = (size * 0.625 + 1.25) * 3.78;
              
              if (x >= shellScreenSize && x <= width - shellScreenSize && 
                  y >= shellScreenSize && y <= height - shellScreenSize) {
                
                let overlaps = false;
                for (let shell of shells) {
                  const dx = shell.x - x;
                  const dy = shell.y - y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  const otherScreenSize = (shell.size * 0.625 + 1.25) * 3.78;
                  const minDist = (shellScreenSize + otherScreenSize) * 0.6 + minDistance;
                  
                  if (dist < minDist) {
                    overlaps = true;
                    break;
                  }
                }
                
                if (!overlaps) {
                  shells.push({ x, y, size, id: shellIndex, timesInvestigated: 0 });
                  placed = true;
                  shellIndex++;
                }
              }
              attempts++;
            }
          }
        }
      }
      
      return shells;
    }

    function init() {
      const shells = generateShells(numShells, dispersion, crabSize);
      const screenSize = (crabSize * 0.625 + 1.25) * 3.78;
      const crab = {
        x: width / 2,
        y: height / 2,
        optimalSize: crabSize,
        screenSize: screenSize,
        currentShellSize: crabSize * 0.8,
        angle: Math.random() * Math.PI * 2,
        speed: 2.5 - (crabSize / 20) * 1.5,
        wanderAngle: 0,
        state: 'exploring',
        currentTarget: null,
        lastInvestigated: null,
        assessmentTime: 0,
        assessmentDuration: 0,
        detectionRange: 800, // Increased detection range significantly
        investigatedShells: {},
        shellChanges: 0,
        lastChangeType: null,
        pathLength: 0,
        lastX: width / 2,
        lastY: height / 2
      };
      
      return { shells, crab };
    }

    if (!simRef.current) {
      simRef.current = init();
    }

    function getShellColor(shell, crabSize) {
      const fitDiff = Math.abs(shell.size - crabSize) / crabSize;
      
      if (fitDiff <= 0.05) {
        return '#22c55e'; // Green - optimal (within 5%)
      } else if (shell.size < crabSize) {
        const intensity = Math.min(Math.abs(fitDiff) * 2, 1);
        const r = 239;
        const g = Math.floor(68 + (1 - intensity) * 150);
        const b = Math.floor(68 + (1 - intensity) * 150);
        return `rgb(${r}, ${g}, ${b})`;
      } else {
        const intensity = Math.min(Math.abs(fitDiff) * 2, 1);
        const r = Math.floor(56 + (1 - intensity) * 150);
        const g = Math.floor(189 + (1 - intensity) * 50);
        const b = Math.floor(248 + (1 - intensity) * 7);
        return `rgb(${r}, ${g}, ${b})`;
      }
    }

    function getCurrentShellColor(currentShellSize, optimalSize) {
      const fitDiff = Math.abs(currentShellSize - optimalSize) / optimalSize;
      
      if (fitDiff <= 0.05) {
        return '#22c55e'; // Green - optimal (within 5%)
      } else if (currentShellSize < optimalSize) {
        const intensity = Math.min(Math.abs(fitDiff) * 2, 1);
        const r = 239;
        const g = Math.floor(68 + (1 - intensity) * 150);
        const b = Math.floor(68 + (1 - intensity) * 150);
        return `rgb(${r}, ${g}, ${b})`;
      } else {
        const intensity = Math.min(Math.abs(fitDiff) * 2, 1);
        const r = Math.floor(56 + (1 - intensity) * 150);
        const g = Math.floor(189 + (1 - intensity) * 50);
        const b = Math.floor(248 + (1 - intensity) * 7);
        return `rgb(${r}, ${g}, ${b})`;
      }
    }

    function drawShell(ctx, shell, crabSize) {
      const shellScreenSize = (shell.size * 0.625 + 1.25) * 3.78;
      const chemicalStrength = shellScreenSize * 1.8;
      
      const gradient = ctx.createRadialGradient(shell.x, shell.y, 0, shell.x, shell.y, chemicalStrength);
      gradient.addColorStop(0, 'rgba(147, 51, 234, 0.15)');
      gradient.addColorStop(1, 'rgba(147, 51, 234, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(shell.x, shell.y, chemicalStrength, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = getShellColor(shell, crabSize);
      ctx.beginPath();
      ctx.arc(shell.x, shell.y, shellScreenSize * 0.6, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.arc(shell.x + shellScreenSize * 0.2, shell.y, shellScreenSize * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    function detectChemicals(crab, shells, memoryLevel) {
      let strongestShell = null;
      let maxStrength = 0;
      
      for (let shell of shells) {
        const timesVisited = crab.investigatedShells[shell.id] || 0;
        
        if (timesVisited > 0) {
          const revisitProbability = 1 - ((memoryLevel - 1) / 9);
          if (Math.random() > revisitProbability) {
            continue;
          }
        }
        
        const dx = shell.x - crab.x;
        const dy = shell.y - crab.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Larger shells emit stronger chemical signals (proportional to size)
        const chemicalStrength = shell.size;
        
        // Chemical strength decreases with square of distance (diffusion-like)
        const perceivedStrength = chemicalStrength / (1 + (dist * dist) / 10000);
        
        if (perceivedStrength > maxStrength && dist > 5) {
          maxStrength = perceivedStrength;
          strongestShell = { shell: shell, strength: perceivedStrength, distance: dist };
        }
      }
      
      return strongestShell;
    }

    function calculateAssessmentTime(shellSize, optimalSize) {
      const fitDiff = Math.abs(shellSize - optimalSize) / optimalSize;
      
      if (fitDiff <= 0.1) {
        return 600;
      } else if (fitDiff >= 0.5) {
        return 300;
      } else {
        const ratio = (fitDiff - 0.1) / (0.5 - 0.1);
        const timeInSeconds = 10 - (5 * ratio);
        return Math.floor(timeInSeconds * 60);
      }
    }

    function shouldSwitch(currentSize, newSize, optimalSize) {
      // Calculate absolute differences from optimal
      const currentFit = Math.abs(currentSize - optimalSize);
      const newFit = Math.abs(newSize - optimalSize);
      
      // Switch if new shell is closer to optimal (better fit)
      return newFit < currentFit;
    }

    function updateCrab(crab, shells) {
      if (crab.state === 'exploring') {
        const detected = detectChemicals(crab, shells, memory);
        
        // Calculate chemotaxis bias based on signal strength
        let chemotaxisBias = 0;
        let targetAngle = crab.angle;
        
        if (detected && detected.shell !== crab.lastInvestigated) {
          const dx = detected.shell.x - crab.x;
          const dy = detected.shell.y - crab.y;
          const dist = detected.distance;
          
          if (dist < 20) {
            // Close enough - start assessing
            crab.currentTarget = detected.shell;
            crab.state = 'assessing';
            crab.assessmentTime = 0;
            
            const visitCount = crab.investigatedShells[detected.shell.id] || 0;
            crab.investigatedShells[detected.shell.id] = visitCount + 1;
            
            let baseTime = calculateAssessmentTime(detected.shell.size, crab.optimalSize);
            
            if (detected.shell.timesInvestigated > 0) {
              baseTime = Math.floor(baseTime * 0.5);
            }
            
            crab.assessmentDuration = baseTime;
            detected.shell.timesInvestigated++;
            return 'running';
          } else {
            // Calculate chemotaxis bias: stronger signal = less randomness
            // Normalize strength to 0-1 range (assuming max strength around 50)
            const normalizedStrength = Math.min(detected.strength / 50, 1);
            chemotaxisBias = normalizedStrength;
            
            targetAngle = Math.atan2(dy, dx);
          }
        }
        
        // Correlated Random Walk with chemotaxis
        // When no signal (bias=0): fully random walk
        // When strong signal (bias=1): mostly directed toward target
        
        if (chemotaxisBias > 0.01) {
          // Blend between current angle and target angle based on signal strength
          const angleDiff = targetAngle - crab.angle;
          const normalizedDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
          
          // Turning rate increases with signal strength
          const turningRate = 0.05 + (chemotaxisBias * 0.25);
          crab.angle += normalizedDiff * turningRate;
          
          // Reduce random component when following chemical gradient
          const randomness = 1 - chemotaxisBias;
          crab.wanderAngle += (Math.random() - 0.5) * 0.5 * randomness;
          crab.wanderAngle = Math.max(-0.5, Math.min(0.5, crab.wanderAngle)) * randomness;
          crab.angle += crab.wanderAngle * 0.1;
        } else {
          // Pure random walk when no chemical detected
          crab.wanderAngle += (Math.random() - 0.5) * 0.6;
          crab.wanderAngle = Math.max(-1, Math.min(1, crab.wanderAngle));
          crab.angle += crab.wanderAngle * 0.2;
        }
        
        const newX = crab.x + Math.cos(crab.angle) * crab.speed;
        const newY = crab.y + Math.sin(crab.angle) * crab.speed;
        
        const dx = newX - crab.lastX;
        const dy = newY - crab.lastY;
        crab.pathLength += Math.sqrt(dx * dx + dy * dy);
        crab.lastX = crab.x;
        crab.lastY = crab.y;
        
        const margin = crab.screenSize;
        if (newX < margin || newX > width - margin) {
          crab.angle = Math.PI - crab.angle;
          crab.wanderAngle = 0;
        }
        if (newY < margin || newY > height - margin) {
          crab.angle = -crab.angle;
          crab.wanderAngle = 0;
        }
        
        crab.x = Math.max(margin, Math.min(width - margin, newX));
        crab.y = Math.max(margin, Math.min(height - margin, newY));
        
      } else if (crab.state === 'assessing') {
        crab.assessmentTime++;
        
        if (crab.assessmentTime >= crab.assessmentDuration) {
          const oldSize = crab.currentShellSize;
          
          if (shouldSwitch(crab.currentShellSize, crab.currentTarget.size, crab.optimalSize)) {
            crab.currentShellSize = crab.currentTarget.size;
            crab.shellChanges++;
            
            const fitDiff = Math.abs(crab.currentShellSize - crab.optimalSize) / crab.optimalSize;
            let changeType;
            if (fitDiff <= 0.05) {
              changeType = 'optimal';
              crab.lastChangeType = 'optimal';
            } else if (crab.currentShellSize > oldSize) {
              changeType = 'larger';
              crab.lastChangeType = 'larger';
            } else {
              changeType = 'smaller';
              crab.lastChangeType = 'smaller';
            }
            
            setChangeHistory(prev => [...prev, changeType]);
            setShellChanges(crab.shellChanges);
          }
          
          const fitDiff = Math.abs(crab.currentShellSize - crab.optimalSize) / crab.optimalSize;
          if (fitDiff <= 0.05) {
            setPathLength(crab.pathLength);
            return 'complete';
          }
          
          crab.lastInvestigated = crab.currentTarget;
          
          const dx = crab.x - crab.currentTarget.x;
          const dy = crab.y - crab.currentTarget.y;
          const awayDist = Math.sqrt(dx * dx + dy * dy);
          
          if (awayDist < 1) {
            crab.angle = Math.random() * Math.PI * 2;
          } else {
            crab.angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * Math.PI / 3;
          }
          
          crab.state = 'exploring';
          crab.currentTarget = null;
          crab.wanderAngle = 0;
          
          // Move away from shell
          for (let i = 0; i < 10; i++) {
            crab.x += Math.cos(crab.angle) * crab.speed;
            crab.y += Math.sin(crab.angle) * crab.speed;
          }
          
          const margin = crab.screenSize;
          crab.x = Math.max(margin, Math.min(width - margin, crab.x));
          crab.y = Math.max(margin, Math.min(height - margin, crab.y));
        }
      }
      
      return 'running';
    }

    function drawCrab(ctx, crab) {
      const currentShellScreenSize = (crab.currentShellSize * 0.625 + 1.25) * 3.78;
      
      const shellColor = getCurrentShellColor(crab.currentShellSize, crab.optimalSize);
      ctx.fillStyle = shellColor;
      ctx.beginPath();
      ctx.arc(crab.x, crab.y, currentShellScreenSize * 0.5, 0, Math.PI * 2);
      ctx.fill();
      
      if (crab.lastChangeType) {
        let lineColor;
        if (crab.lastChangeType === 'optimal') {
          lineColor = '#22c55e';
        } else if (crab.lastChangeType === 'larger') {
          lineColor = '#38bdf8';
        } else {
          lineColor = '#ef4444';
        }
        
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const lineY = crab.y;
        const lineStartX = crab.x - currentShellScreenSize * 0.4;
        const lineEndX = crab.x + currentShellScreenSize * 0.4;
        ctx.moveTo(lineStartX, lineY);
        ctx.lineTo(lineEndX, lineY);
        ctx.stroke();
      }

      ctx.fillStyle = '#f97316';
      ctx.beginPath();
      ctx.arc(crab.x, crab.y, crab.screenSize * 0.6, 0, Math.PI * 2);
      ctx.fill();

      const clawAngle1 = crab.angle - Math.PI / 4;
      const clawAngle2 = crab.angle + Math.PI / 4;
      
      ctx.strokeStyle = '#ea580c';
      ctx.lineWidth = Math.max(2, crab.screenSize * 0.15);
      ctx.beginPath();
      ctx.moveTo(crab.x, crab.y);
      ctx.lineTo(
        crab.x + Math.cos(clawAngle1) * crab.screenSize,
        crab.y + Math.sin(clawAngle1) * crab.screenSize
      );
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(crab.x, crab.y);
      ctx.lineTo(
        crab.x + Math.cos(clawAngle2) * crab.screenSize,
        crab.y + Math.sin(clawAngle2) * crab.screenSize
      );
      ctx.stroke();

      ctx.fillStyle = '#000';
      const eyeOffset = crab.screenSize * 0.4;
      const eyeSize = Math.max(2, crab.screenSize * 0.1);
      ctx.beginPath();
      ctx.arc(
        crab.x + Math.cos(crab.angle - 0.3) * eyeOffset,
        crab.y + Math.sin(crab.angle - 0.3) * eyeOffset,
        eyeSize,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.beginPath();
      ctx.arc(
        crab.x + Math.cos(crab.angle + 0.3) * eyeOffset,
        crab.y + Math.sin(crab.angle + 0.3) * eyeOffset,
        eyeSize,
        0,
        Math.PI * 2
      );
      ctx.fill();

      if (crab.state === 'assessing') {
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(crab.x, crab.y, crab.screenSize * 1.3, 0, Math.PI * 2);
        ctx.stroke();
        
        const progress = crab.assessmentTime / crab.assessmentDuration;
        ctx.strokeStyle = '#22c55e';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(crab.x, crab.y, crab.screenSize * 1.3, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
        ctx.stroke();
      }
    }

    function animate() {
      if (!isRunning) return;
      
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, width, height);
      
      const { shells, crab } = simRef.current;
      
      if (startTimeRef.current) {
        const elapsed = (Date.now() - startTimeRef.current) / 1000;
        setElapsedTime(elapsed);
      }
      
      const status = updateCrab(crab, shells);
      
      if (status === 'complete') {
        setIsRunning(false);
        setIsComplete(true);
      }
      
      shells.forEach(shell => drawShell(ctx, shell, crabSize));
      drawCrab(ctx, crab);
      
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 20px monospace';
      ctx.fillText(`Time: ${elapsedTime.toFixed(2)}s`, 10, 25);
      
      ctx.font = '12px monospace';
      ctx.fillText(`State: ${crab.state}`, 10, 45);
      const currentFit = ((crab.currentShellSize - crab.optimalSize) / crab.optimalSize * 100).toFixed(1);
      ctx.fillText(`Shell fit: ${currentFit}%`, 10, 60);
      ctx.fillText(`Shell changes: ${crab.shellChanges}`, 10, 75);
      
      ctx.fillStyle = '#22c55e';
      ctx.fillRect(width - 140, 8, 15, 15);
      ctx.fillStyle = '#fff';
      ctx.fillText('Optimal', width - 120, 20);
      
      ctx.fillStyle = '#38bdf8';
      ctx.fillRect(width - 140, 28, 15, 15);
      ctx.fillStyle = '#fff';
      ctx.fillText('Too large', width - 120, 40);
      
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(width - 140, 48, 15, 15);
      ctx.fillStyle = '#fff';
      ctx.fillText('Too small', width - 120, 60);
      
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.fillText('Shell changes:', width - 140, 85);
      
      let tallyX = width - 140;
      let tallyY = 100;
      changeHistory.forEach((changeType, index) => {
        if (changeType === 'optimal') {
          ctx.strokeStyle = '#22c55e';
        } else if (changeType === 'larger') {
          ctx.strokeStyle = '#38bdf8';
        } else {
          ctx.strokeStyle = '#ef4444';
        }
        
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(tallyX + (index % 10) * 8, tallyY);
        ctx.lineTo(tallyX + (index % 10) * 8, tallyY + 10);
        ctx.stroke();
        
        if ((index + 1) % 10 === 0) {
          tallyY += 15;
        }
      });
      
      if (isComplete) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = '#22c55e';
        ctx.font = 'bold 40px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('OPTIMAL SHELL FOUND!', width / 2, height / 2);
        ctx.font = 'bold 28px monospace';
        ctx.fillText(`Time: ${elapsedTime.toFixed(2)}s`, width / 2, height / 2 + 45);
      }
      
      animationFrameRef.current = requestAnimationFrame(animate);
    }

    if (isRunning) {
      if (!startTimeRef.current) {
        startTimeRef.current = Date.now();
      }
      animate();
    }

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [isRunning, crabSize, numShells, dispersion, memory, elapsedTime, isComplete, changeHistory]);

  const handleStart = () => {
    if (!simRef.current) {
      handleReset();
    }
    startTimeRef.current = Date.now();
    setElapsedTime(0);
    setIsComplete(false);
    setIsRunning(true);
    setTotalRuns(prev => prev + 1);
  };

  const handleReset = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, width, height);
    
    simRef.current = null;
    startTimeRef.current = null;
    setElapsedTime(0);
    setIsComplete(false);
    setShellChanges(0);
    setChangeHistory([]);
    setPathLength(0);
    setIsRunning(false);
  };

  const handleRandomize = () => {
    setCrabSize(Math.floor(Math.random() * 20) + 1);
    setNumShells(Math.floor(Math.random() * 26) + 5);
    setDispersion(Math.floor(Math.random() * 101));
    setMemory(Math.floor(Math.random() * 10) + 1);
    setTimeout(handleReset, 100);
  };

  const handleSaveData = () => {
    if (!crabName.trim()) {
      alert('Please enter a crab name before saving!');
      return;
    }
    
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US');
    const timeStr = now.toLocaleTimeString('en-US');
    
    const csvContent = `Crab Name,Date,Time,Duration (s),Shell Changes,Path Length,Crab Size,Number of Shells,Dispersion,Memory
${crabName},${dateStr},${timeStr},${elapsedTime.toFixed(2)},${shellChanges},${pathLength.toFixed(2)},${crabSize},${numShells},${dispersion},${memory}`;
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `hermit_crab_${crabName.replace(/\s+/g, '_')}_${Date.now()}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="w-full min-h-screen bg-slate-900 flex items-center justify-center p-4">
      <div className="bg-slate-800 rounded-lg shadow-2xl p-6 max-w-5xl w-full">
        <h1 className="text-2xl font-bold text-white mb-4">Hermit Crab Shell Search Simulation</h1>
        
        <canvas
          ref={canvasRef}
          width={900}
          height={600}
          className="w-full border-2 border-slate-700 rounded mb-4"
        />
        
        <div className="space-y-4">
          <div className="flex gap-2 flex-wrap">
            <button
              onClick={handleStart}
              disabled={isRunning}
              className="flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 text-white rounded transition-colors"
            >
              <Play size={16} />
              Start
            </button>
            <button
              onClick={() => setIsRunning(false)}
              disabled={!isRunning}
              className="flex items-center gap-2 px-4 py-2 bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white rounded transition-colors"
            >
              <Pause size={16} />
              Pause
            </button>
            <button
              onClick={handleReset}
              className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors"
            >
              <RotateCcw size={16} />
              Reset
            </button>
            <button
              onClick={handleRandomize}
              className="flex items-center gap-2 px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded transition-colors"
            >
              <Shuffle size={16} />
              Randomize
            </button>
          </div>
          
          <div className="bg-slate-700 p-3 rounded">
            <label className="text-white text-sm mb-2 block">Name Your Crab:</label>
            <div className="flex gap-2">
              <input
                type="text"
                value={crabName}
                onChange={(e) => setCrabName(e.target.value)}
                placeholder="Enter crab name"
                className="flex-1 px-3 py-2 bg-slate-600 text-white rounded border border-slate-500"
              />
              <button
                onClick={handleSaveData}
                disabled={!isComplete}
                className="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 text-white rounded transition-colors"
              >
                Save Data
              </button>
            </div>
          </div>
          
          <div className="text-white text-sm bg-slate-700 p-2 rounded">
            <p>Total Simulations Run: {totalRuns}</p>
          </div>
          
          <div className="space-y-3">
            <div>
              <label className="text-white text-sm mb-1 block">
                Crab Size: {crabSize} ({(crabSize * 0.625 + 1.25).toFixed(1)}mm)
              </label>
              <input
                type="range"
                min="1"
                max="20"
                step="1"
                value={crabSize}
                onChange={(e) => {
                  setCrabSize(parseFloat(e.target.value));
                  handleReset();
                }}
                className="w-full"
              />
            </div>
            
            <div>
              <label className="text-white text-sm mb-1 block">
                Number of Shells: {numShells}
              </label>
              <input
                type="range"
                min="5"
                max="30"
                step="1"
                value={numShells}
                onChange={(e) => {
                  setNumShells(parseInt(e.target.value));
                  handleReset();
                }}
                className="w-full"
              />
            </div>
            
            <div>
              <label className="text-white text-sm mb-1 block">
                Dispersion: {dispersion < 33 ? 'Clumped' : dispersion < 67 ? 'Moderate (random clusters)' : 'Dispersed'}
              </label>
              <input
                type="range"
                min="0"
                max="100"
                step="1"
                value={dispersion}
                onChange={(e) => {
                  setDispersion(parseInt(e.target.value));
                  handleReset();
                }}
                className="w-full"
              />
            </div>
            
            <div>
              <label className="text-white text-sm mb-1 block">
                Memory: {memory} {memory === 1 ? '(revisits shells)' : memory === 10 ? '(never revisits)' : ''}
              </label>
              <input
                type="range"
                min="1"
                max="10"
                step="1"
                value={memory}
                onChange={(e) => setMemory(parseInt(e.target.value))}
                className="w-full"
              />
            </div>
          </div>
        </div>
        
        <div className="mt-4 text-sm text-slate-300 space-y-1">
          <p>• Crab starts with a shell 80% of optimal size</p>
          <p>• Shell distribution: ~50% too large (blue), ~50% too small (red), 1 optimal (green)</p>
          <p>• Investigation time: 10s for good fits (90-110%), 5s for bad fits (≤50%)</p>
          <p>• Memory: controls likelihood of revisiting shells (1=always revisit, 10=never revisit)</p>
          <p>• Shell changes: indicated by colored line on shell (red=smaller, blue=larger, green=optimal)</p>
          <p>• Crab cannot leave screen boundaries (bounces off edges)</p>
          <p>• Re-investigating a shell takes 50% less time</p>
        </div>
      </div>
    </div>
  );
};

export default HermitCrabSimulation;
